// SPDX-License-Identifier: MIT

package io.github.northmaxdev.coinplot.domain;

import java.math.BigDecimal;
import java.time.Instant;
import java.time.LocalDate;
import java.time.LocalTime;
import java.time.ZoneId;

import static java.util.Objects.requireNonNull;

/**
 * Exchange rate, with a publication timestamp.
 * <p>
 * <b>This class stores the exchange rate value stripped of its trailing zeros (if there are any).</b>
 * After all, an exchange rate is essentially a price, and trailing zeros are meaningless in prices.
 * This is done for the sake of business logic correctness and consistency ({@link #equals(Object)}, {@link #hashCode()}, exchange rate
 * arithmetic, etc.)
 *
 * @see <a href="https://www.investopedia.com/terms/e/exchangerate.asp">
 * Exchange Rates: What They Are, How They Work, and Why They Fluctuate - Investopedia</a>
 */
public record ExchangeRate(CurrencyPair currencyPair, BigDecimal value, Instant timestamp) {

    // https://data.ecb.europa.eu/methodology/exchange-rates
    private static final LocalTime ECB_LOCAL_PUBLICATION_TIME = LocalTime.of(16, 0);
    private static final ZoneId ECB_TIME_ZONE = ZoneId.of("Europe/Berlin");

    /**
     * Main constructor.
     * <p>
     * <b>Reminder:</b> the exchange rate value is stripped of its trailing zeros (by calling {@link BigDecimal#stripTrailingZeros()}).
     *
     * @throws IllegalArgumentException if the exchange rate {@code value} argument is zero or negative
     */
    public ExchangeRate(CurrencyPair currencyPair, BigDecimal value, Instant timestamp) {
        this.currencyPair = requireNonNull(currencyPair);
        this.timestamp = requireNonNull(timestamp);

        if (value.signum() <= 0) { // Implicit null-check
            throw new IllegalArgumentException("exchange rate value must be positive (got " + value.toPlainString() + ')');
        }
        this.value = value.stripTrailingZeros();
    }

    /**
     * This static factory method represents a shortcut to create exchange rates published by the
     * <a href="https://www.ecb.europa.eu/home/html/index.en.html">European Central Bank (ECB)</a>.
     * <p>
     * The ECB generally publishes exchange rates daily at around 16:00 CET; therefore, a local date is enough to compute the timestamp.
     * <p>
     * The {@link BigDecimal} validations of the main constructor apply to this method as well.
     *
     * @see #ExchangeRate(CurrencyPair, BigDecimal, Instant)
     * @see <a href="https://data.ecb.europa.eu/methodology/exchange-rates">Euro foreign exchange reference rates <i>(this is where 16:00
     * CET is mentioned)</i></a>
     */
    public static ExchangeRate publishedByEcb(CurrencyPair currencyPair, BigDecimal value, LocalDate publicationDate) {
        Instant timestamp = publicationDate.atTime(ECB_LOCAL_PUBLICATION_TIME)
                .atZone(ECB_TIME_ZONE)
                .toInstant();

        return new ExchangeRate(currencyPair, value, timestamp);
    }

    /**
     * Applies this exchange rate to the given base currency amount.
     *
     * @param baseCurrencyAmount any value (zero and negative is OK)
     * @return the product of {@code baseCurrencyAmount * exchangeRateValue}, stripped of its trailing zeros
     * @see BigDecimal#multiply(BigDecimal)
     * @see BigDecimal#stripTrailingZeros()
     */
    public BigDecimal apply(BigDecimal baseCurrencyAmount) {
        return baseCurrencyAmount.multiply(value).stripTrailingZeros();
    }

    // There's no need to manually override equals() and hashCode() despite having a BigDecimal property.
    // Since we're stripping trailing zeros at instantiation time, BigDecimal comparison with equals() and compareTo()
    // are effectively equivalent. Therefore, whatever impl is generated by java.lang.Record should be OK.
    // See more info regarding BigDecimal equality here: https://www.baeldung.com/java-bigdecimal-equals-compareto-difference

    /**
     * The industry convention for formatting exchange rates is {@code FOO/BAR 1.2345}. This method follows this convention, with the
     * timestamp appended to the end. The formatting of the timestamp is subject to change and should not be relied upon.
     */
    @Override
    public String toString() {
        // The timestamp as-is might be hard to read in logs, consider using a dedicated DateTimeFormatter.
        return currencyPair + " " + value.toPlainString() + ' ' + timestamp;
    }
}
