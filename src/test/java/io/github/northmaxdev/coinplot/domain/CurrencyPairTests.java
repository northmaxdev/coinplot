// SPDX-License-Identifier: MIT

package io.github.northmaxdev.coinplot.domain;

import nl.jqno.equalsverifier.EqualsVerifier;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.CsvFileSource;
import org.junit.jupiter.params.provider.ValueSource;

import java.math.BigDecimal;
import java.util.Currency;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;
import static org.assertj.core.api.Assertions.assertThatNoException;

class CurrencyPairTests {

    @Nested
    class CanonicalConstructor {

        @Test
        void throwsIaeOnSameCurrencies() {
            Currency euro = Currency.getInstance("EUR");

            assertThatIllegalArgumentException().isThrownBy(() -> new CurrencyPair(euro, euro));
        }

        @Test
        void doesNotThrowOnDifferentCurrencies() {
            Currency euro = Currency.getInstance("EUR");
            Currency usDollar = Currency.getInstance("USD");

            assertThatNoException().isThrownBy(() -> new CurrencyPair(euro, usDollar));
        }
    }

    // Note: it's OK to use CurrencyPair.fromIsoCodes() instead of the canonical constructor for brevity in test code.
    // fromIsoCodes() is no more than just a one-liner shortcut to call Currency.getInstance() and immediately delegate to the canonical
    // constructor. It does not and should not have any additional logic besides that.

    @Nested
    class InvolvesCurrency {

        @Test
        void returnsTrueOnInvolvedBase() {
            CurrencyPair pair = CurrencyPair.fromIsoCodes("EUR", "USD");
            Currency euro = Currency.getInstance("EUR");

            assertThat(pair.involves(euro)).isTrue();
        }

        @Test
        void returnsTrueOnInvolvedQuote() {
            CurrencyPair pair = CurrencyPair.fromIsoCodes("EUR", "USD");
            Currency usDollar = Currency.getInstance("USD");

            assertThat(pair.involves(usDollar)).isTrue();
        }

        @ParameterizedTest
        @ValueSource(strings = {"JPY", "CHF", "GBP", "KRW", "CAD", "AUD"})
        void returnsFalseOnUninvolvedCurrency(String currencyCode) {
            CurrencyPair pair = CurrencyPair.fromIsoCodes("EUR", "USD");
            Currency currency = Currency.getInstance(currencyCode);

            assertThat(pair.involves(currency)).isFalse();
        }

        @Test
        void returnsFalseOnNull() {
            CurrencyPair pair = CurrencyPair.fromIsoCodes("EUR", "USD");

            assertThat(pair.involves(null)).isFalse();
        }
    }

    @ParameterizedTest
    @CsvFileSource(resources = "/currency_pair_pips_test_data.csv") // Test data generated by Claude 4 Sonnet
    void returnsExpectedPipDefinitionForPair(String baseCode, String quoteCode, BigDecimal expectedPipDefinition) {
        CurrencyPair currencyPair = CurrencyPair.fromIsoCodes(baseCode, quoteCode);

        assertThat(currencyPair.getPipDefinition()).isEqualTo(expectedPipDefinition);
    }

    @Test
    void toStringReturnsExpectedFormat() {
        CurrencyPair euroToSwissFranc = CurrencyPair.fromIsoCodes("EUR", "CHF");

        assertThat(euroToSwissFranc.toString()).isEqualTo("EUR/CHF");
    }

    @Test
    void equalsContract() {
        // An internal invariant of CurrencyPair is that it never involves the same currency twice.
        // If we let EqualsVerifier use random currencies, it'll generate something like EUR/EUR, which is not allowed.
        // We should provide prefab values where possible options for "base" do not intersect with possible options for "quote".

        Currency euro = Currency.getInstance("EUR");
        Currency swissFranc = Currency.getInstance("CHF");
        Currency britishPound = Currency.getInstance("GBP");
        Currency canadianDollar = Currency.getInstance("CAD");

        EqualsVerifier.forClass(CurrencyPair.class)
                .withPrefabValuesForField("base", euro, swissFranc)
                .withPrefabValuesForField("quote", britishPound, canadianDollar)
                .verify();
    }
}